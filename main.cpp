/* I decided to make a small snake in cpp after seeing a battle of snakes controlled by the computer and generated by an AI.
 * I want to do everything in cpp, with the fewest library, i will use ncurses, but not like unity or something like this.
 *
 * The screen is from up to bottom, then left to right.
 * the snake can be in:
 * (1,2) (1,4) (1,6) (1,8) (1,10)
 * (2,2) (2,4) (2,6) (2,8) (2,10)
 * (3,2) (3,4) (3,6) (3,8) (3,10)
 * (4,2) (4,4) (4,6) (4,8) (4,10)
 * (5,2) (5,4) (5,6) (5,8) (5,10) 
 *
 */

#include <iostream>
#include <deque>
#include <cstdlib>
#include <ctime>
#include <ncurses.h>
#include <chrono>
#include <thread>

using namespace std;

class Coordonnees;

void printWall();
void printSnake(deque<Coordonnees> snake, int snakeSize);
int getDirection(int currentDirection);
bool nextPlaceIsApple(deque<Coordonnees> snake, int direction, Coordonnees apple);
bool nextPlaceIsWall(deque<Coordonnees> snake, int direction, Coordonnees apple);
Coordonnees getNextCoordonnes(deque<Coordonnees> snake, int direction);

class Coordonnees {
public:
  int x;
  int y;
  Coordonnees(int newX, int newY) {
    x = newX;
    y = newY;
  }
  bool equals(Coordonnees next) {
    return x==next.x && y==next.y;
  }
};



int main(int argc, char ** argv) {

  initscr();

  srand(time(0));

  deque<Coordonnees> snake;
  snake.push_back(Coordonnees(rand() % 5, rand() % 5));
  int snakeSize = 1;

  Coordonnees apple = Coordonnees(rand() % 5, rand() % 5);

//TODO: make a string with everything that will be printed (clear and refresh) with a function to print the screen with the snake and all (mvprint(10, 20, "#")) (and a wall)

  printWall();

  for (int i = 1; i < 6; i++) {
    for (int j = 1; j < 6; j++) {
      mvprintw(i, j*2, "#");
    }
  }

  refresh();

  std::this_thread::sleep_for(std::chrono::milliseconds(1200));

  clear();

  // TODO: starting direction
  printWall();
  printSnake(snake, snakeSize);
  refresh();
  keypad(stdscr, TRUE);
  noecho();
  int direction = getDirection(1);






  nodelay(stdscr, true);

  // TODO: make a menu with options

  while (true) {
    std::this_thread::sleep_for(std::chrono::milliseconds(500));

    // snake movement logic
    // change direction, if wall, lose, if snake, lose, if apple, remove, if none, advance snakes
    direction = getDirection(direction);
    if (nextPlaceIsApple(snake, direction, apple)) {
      snake.push_front(apple);
      snakeSize += 1;
    } else if (nextPlaceIsWall(snake, direction, apple)) {
      break;
    } else {
      // move snake depending on the direction
      snake.push_front(getNextCoordonnes(snake, direction));
      snake.pop_back();
    }


    // apple logic
    // if exist, dont do anything
    // if doesnt exist, add one randomly, not on snake, not in wall

    // print logic
    // clear screen, print wall, print snake, print apple
    clear();
    printWall();
    printSnake(snake, snakeSize);
    
    refresh();

  }

  clear();
  printw("Game Over!");
  refresh();
  getch();
  endwin();

  return 0;

}

void printWall() {
  mvprintw(0, 0, "# # # # # # #");
  for (int i = 1; i < 6; i++) {
    mvprintw(i, 0, "#           #");
  }
  mvprintw(6, 0, "# # # # # # #");
}

void printSnake(deque<Coordonnees> snake, int snakeSize) {
  for (int i = 0; i < snakeSize; i++) {
    mvprintw(snake[i].x + 1, (snake[i].y + 1) * 2, "#");
  }
}

int getDirection(int currentDirection) {
  int fleche = getch();
  int ch = currentDirection;
  if (ch == KEY_UP) {
    ch = 0;
  } else if (ch == KEY_RIGHT) {
    ch = 1;
  } else if (ch == KEY_DOWN) {
    ch = 2;
  } else if (ch == KEY_LEFT) {
    ch = 3;
  }
  return ch;
}

bool nextPlaceIsApple(deque<Coordonnees> snake, int direction, Coordonnees apple) {
  if (getNextCoordonnes(snake, direction).equals(apple)) {
    return true;
  }
  return false;
}

bool nextPlaceIsWall(deque<Coordonnees> snake, int direction, Coordonnees apple) {
  return false;
}

Coordonnees getNextCoordonnes(deque<Coordonnees> snake, int direction) {
Coordonnees getNextCoordonnes(deque<Coordonnees> snake, int direction);
  Coordonnees next = Coordonnees(0,0);
  Coordonnees head = snake.front();
  if (direction == 0) {
    next = Coordonnees(head.x-1, head.y);
  } else if (direction == 1) {
    next = Coordonnees(head.x, head.y+1);
  } else if (direction == 2) {
    next = Coordonnees(head.x+1, head.y);
  } else if (direction == 3) {
    next = Coordonnees(head.x, head.y-1);
  }
  return next;
}


